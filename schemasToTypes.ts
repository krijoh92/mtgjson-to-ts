import {camelCase, capitalCase} from 'change-case'
import fetch from 'node-fetch'
import {compileFromFile} from 'json-schema-to-typescript'
import {writeFileSync, unlinkSync} from 'fs'

const baseUrl =
  'https://github.com/mtgjson/mtgjson-website/raw/master/docs/.vuepress/public/schemas'

const files = [
  'card',
  'cardTypes',
  'compiledList',
  'deck',
  'files',
  'foreignData',
  'identifiers',
  'keywords',
  'leadershipSkills',
  'legalities',
  'meta',
  'purchaseUrls',
  'rulings',
  'set',
  'translations',
  'types',
]

const splits = [
  {property: 'Atomic', name: 'Atomic'},
  {property: 'Token', name: 'Token'},
  {property: 'Manifest', name: 'List'},
]

async function doCompile() {
  const ts = await compileFromFile(`./all.schema.json`, {
    style: {semi: false, trailingComma: 'es5', singleQuote: true, tabWidth: 2},
    bannerComment: `
    /* eslint:disable */
    /**
     * This file was automatically generated by json-schema-to-typescript.
     * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
     * and run json-schema-to-typescript to regenerate this file.
     */
    `,
  })

  writeFileSync(`./mtgjson.ts`, ts)
}

function fixTypeRef(data: any) {
  const refRegexp = new RegExp(/link@([^}}]{1,})@\/data-models/)
  const exampleTypes = data.example.replace(/\[\]/, '').split(',')
  const matches = exampleTypes.map(t => t.match(refRegexp)).filter(t => t)

  const itemRefs: string[] = []

  for (const match of matches) {
    const subMatch = match[1].match(/\((.{1,})\)/)

    const typeRef = subMatch
      ? camelCase(
          `${match[1].replace(/\(.{1,}\)/, '')}${capitalCase(subMatch[1]).replace(
            capitalCase(match[1].replace(/\(.{1,}\)/, '')),
            ''
          )}`
        )
      : camelCase(match[1])
    itemRefs.push(`#/definitions/${typeRef}`)
  }

  return itemRefs
}

function fixBrokenFields(data: any) {
  const arrayRegxp = new RegExp(/array\((string|object)\)/)
  const properties = Object.keys(data)

  const newObj = {}

  for (const property of properties) {
    const fieldTypes = data[property].type
      .split('|')
      .map(t => t.replace(/\s/, ''))
      .filter(t => t !== 'array()' && t)

    const propertyTypes = fieldTypes
      .map(t => {
        const isArray = t.match(arrayRegxp)

        if (isArray) {
          const [, type] = isArray
          if (type === '') {
            return {type: 'null'}
          }

          if (type === 'object' && data[property].example) {
            const objectRef = fixTypeRef(data[property])

            if (objectRef.length === 0) {
              return {properties: {}}
            }

            return objectRef.length === 1
              ? {type: 'array', items: {$ref: objectRef[0]}}
              : {type: 'array', items: objectRef.map(ref => ({$ref: ref}))}
          } else {
            return {type: 'array', items: {type}}
          }
        }

        if (t === 'object' && data[property].example) {
          const objectRef = fixTypeRef(data[property])
          return objectRef.length === 1 ? {$ref: objectRef[0]} : objectRef.map(ref => ({$ref: ref}))
        }

        return t === 'array' // default to string when not defined in array typing
          ? {type: t, items: {type: 'string'}}
          : {type: t.replace('float', 'number')}
      })
      .reduce((sum, next) => sum.concat(Array.isArray(next) ? next : [next]), [])

    if (propertyTypes.length > 1) {
      newObj[property] = {anyOf: propertyTypes}
    } else if (propertyTypes.length === 1) {
      newObj[property] = propertyTypes[0]
    } else {
      newObj[property] = {}
    }
  }
  return newObj
}

function findRequiredFields(data: any) {
  const required = []

  for (const key of Object.keys(data)) {
    if (!data[key].attributes) {
      required.push(key)
    }
  }

  return required.length === 0 ? undefined : required
}

function generateSplitType(data: any, split: string) {
  const newObj = {}

  for (const property of Object.keys(data)) {
    if (data[property][`is${split}Property`]) newObj[property] = data[property]
    if (data[property][`is${split}OnlyProperty`]) delete data[property]
  }

  return Object.keys(newObj).length > 0 ? newObj : null
}

async function downloadFiles() {
  const jsonData: any = {
    type: 'object',
    title: 'MTGJSON',
    schema: 'http://json-schema.org/draft-07/schema',
    properties: {},
    definitions: {},
  }

  for (const file of files) {
    const res = await fetch(`${baseUrl}/${file}.schema.json`)
    const json = await res.json()

    for (const split of splits) {
      const splitType = generateSplitType(json, split.property)
      if (splitType) {
        const splitReq = findRequiredFields(splitType)
        const fixedSplit = fixBrokenFields(splitType)
        const id = `#/definitions/${file}${split.name}`
        jsonData.definitions[`${file}${split.name}`] = {
          properties: fixedSplit,
          $id: id,
          title: capitalCase(`${file}${split.name}`),
          required: splitReq,
        }
        jsonData.properties[`${file}${split.name}`] = {$ref: id}
      }
    }

    const required = findRequiredFields(json)
    const fixedJSON = fixBrokenFields(json)
    const id = `#/definitions/${file}`
    jsonData.definitions[file] = {
      properties: fixedJSON,
      $id: id,
      title: capitalCase(file),
      required,
    }
    jsonData.properties[file] = {$ref: id}
  }

  writeFileSync('./all.schema.json', JSON.stringify(jsonData, undefined, 2))
  doCompile()
  unlinkSync('./all.schema.json')
}

downloadFiles()
